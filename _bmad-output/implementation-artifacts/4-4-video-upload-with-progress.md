# Story 4.4: Video Upload with Progress

Status: done

## Story

As a **Participant**,
I want **to upload a video file with real-time progress feedback**,
So that **I can submit my video entry and know it's uploading successfully**.

## Acceptance Criteria

### AC1: Upload Form Display
**Given** I click "Submit" on a video category
**When** I see the upload form
**Then** I see a file picker accepting video formats: .mp4, .mkv, .m4v, .mov, .avi, .flv, .wmv, .ts, .mpeg
**And** I see the maximum file size: 500MB

### AC2: Valid Upload Start
**Given** I select a valid video file under 500MB
**When** the upload begins
**Then** I see the UploadProgress component with: file name, progress bar, percentage, upload speed
**And** the submission timestamp is recorded NOW (not when upload completes)

### AC3: Real-time Progress
**Given** the upload is in progress
**When** I watch the progress
**Then** the progress bar updates smoothly in real-time
**And** I cannot navigate away without a warning

### AC4: Upload Complete
**Given** the upload completes
**When** the file is processed
**Then** I see "Processing..." state briefly
**And** then I am redirected to the preview page

### AC5: File Too Large
**Given** I select a file over 500MB
**When** I try to upload
**Then** I see an error "File too large. Maximum size is 500MB"
**And** the upload does not start

### AC6: Invalid File Type
**Given** I select an unsupported file format
**When** I try to upload
**Then** I see an error "Invalid file type. Supported formats: MP4, MKV, MOV, AVI, WMV, FLV, TS, MPEG"

### AC7: Upload Failure & Retry
**Given** the upload fails (network error)
**When** the error occurs
**Then** I see an error message with "Retry" button
**And** the upload can resume from where it left off (resumable)

### AC8: Signed URL Generation
**Given** the Supabase Edge Function runs
**When** I request an upload URL
**Then** a signed Bunny Stream URL is returned
**And** the upload goes directly to Bunny (not through our server)

### AC9: Database Schema
**Given** the database migration runs for this story
**When** I check the schema
**Then** `submissions` table exists with: id, participant_id, category_id, media_type, media_url, bunny_video_id, thumbnail_url, status, submitted_at, created_at, updated_at

## Developer Context

### Architecture Requirements

**Critical: Bunny Upload Security**
- NEVER expose Bunny credentials to the client
- All uploads use signed URLs generated by Edge Functions
- Edge Function validates: participant codes valid, category is published, participant has not already submitted

**Data Flow:**
1. Client requests signed upload URL from Edge Function
2. Edge Function validates participant session and category state
3. Edge Function creates submission record with status='uploading', submitted_at=NOW()
4. Edge Function generates signed Bunny Stream TUS URL
5. Client uploads directly to Bunny using TUS protocol (resumable)
6. On upload complete, client calls Edge Function to finalize submission
7. Edge Function updates submission record with media_url, status='submitted'

**Bunny Stream Integration:**
- Video uploads go to Bunny Stream (streaming-optimized)
- Use TUS protocol for resumable uploads
- Bunny Stream returns video_id for playback URL construction
- Playback URL format: `https://iframe.mediadelivery.net/embed/{library_id}/{video_id}`

### Technical Requirements

**Feature Location:** `src/features/submissions/`

**New/Modified Files:**
```
src/features/submissions/
├── api/
│   └── submissionsApi.ts              # NEW: API functions
├── components/
│   ├── UploadProgress.tsx             # NEW: Progress display component
│   ├── UploadProgress.test.tsx        # NEW: Tests
│   ├── VideoUploadForm.tsx            # NEW: Upload form with file picker
│   ├── VideoUploadForm.test.tsx       # NEW: Tests
│   └── index.ts                       # NEW: Component exports
├── hooks/
│   ├── useVideoUpload.ts              # NEW: Upload hook with TUS
│   ├── useSubmission.ts               # NEW: Submission query hook
│   └── index.ts                       # NEW: Hook exports
├── types/
│   └── submission.types.ts            # NEW: Type definitions
└── index.ts                           # MODIFY: Export all

src/pages/participant/
├── VideoUploadPage.tsx                # NEW: Upload page
└── VideoUploadPage.test.tsx           # NEW: Tests

src/router/
└── router.tsx                         # MODIFY: Add upload route

supabase/functions/
├── create-video-upload/               # NEW: Generate signed URL
│   └── index.ts
└── finalize-upload/                   # NEW: Complete submission
    └── index.ts

supabase/migrations/
└── YYYYMMDDHHMMSS_create_submissions.sql  # NEW: Submissions table
```

### Database Migration

**supabase/migrations/YYYYMMDDHHMMSS_create_submissions.sql:**

```sql
-- Create submissions table
CREATE TABLE public.submissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  participant_id UUID NOT NULL REFERENCES public.participants(id) ON DELETE CASCADE,
  category_id UUID NOT NULL REFERENCES public.categories(id) ON DELETE CASCADE,
  media_type TEXT NOT NULL CHECK (media_type IN ('video', 'photo')),
  media_url TEXT,
  bunny_video_id TEXT,
  thumbnail_url TEXT,
  status TEXT NOT NULL DEFAULT 'uploading' CHECK (status IN ('uploading', 'submitted', 'disqualified')),
  submitted_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- One submission per participant per category
  UNIQUE(category_id, participant_id)
);

-- Enable RLS
ALTER TABLE public.submissions ENABLE ROW LEVEL SECURITY;

-- Index for common queries
CREATE INDEX idx_submissions_participant_id ON public.submissions(participant_id);
CREATE INDEX idx_submissions_category_id ON public.submissions(category_id);
CREATE INDEX idx_submissions_status ON public.submissions(status);

-- RLS Policies
-- Admin can do everything
CREATE POLICY "Admin full access to submissions"
  ON public.submissions
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE id = auth.uid() AND role = 'admin'
    )
  );

-- Judge can read submissions for their assigned categories
CREATE POLICY "Judge read assigned category submissions"
  ON public.submissions
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.categories c
      JOIN public.profiles p ON p.id = auth.uid()
      WHERE c.id = submissions.category_id
        AND c.judge_id = p.id
        AND p.role = 'judge'
    )
  );

-- Participants access via Edge Functions only (no direct RLS)
-- Edge Functions use service_role key

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_submissions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER submissions_updated_at
  BEFORE UPDATE ON public.submissions
  FOR EACH ROW
  EXECUTE FUNCTION update_submissions_updated_at();
```

### Edge Function: create-video-upload

**supabase/functions/create-video-upload/index.ts:**

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface UploadRequest {
  contestId: string;
  categoryId: string;
  participantId: string;
  participantCode: string;
  fileName: string;
  fileSize: number;
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  if (req.method !== 'POST') {
    return new Response(
      JSON.stringify({ success: false, error: 'METHOD_NOT_ALLOWED' }),
      { status: 405, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  try {
    const {
      contestId,
      categoryId,
      participantId,
      participantCode,
      fileName,
      fileSize,
    }: UploadRequest = await req.json();

    // Validate required fields
    if (!contestId || !categoryId || !participantId || !participantCode || !fileName) {
      throw new Error('MISSING_REQUIRED_FIELDS');
    }

    // Validate file size (500MB max)
    const MAX_SIZE = 500 * 1024 * 1024;
    if (fileSize > MAX_SIZE) {
      return new Response(
        JSON.stringify({ success: false, error: 'FILE_TOO_LARGE' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const supabaseAdmin = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
      { auth: { autoRefreshToken: false, persistSession: false } }
    );

    // Verify participant belongs to contest
    const { data: participant, error: participantError } = await supabaseAdmin
      .from('participants')
      .select('id, status')
      .eq('id', participantId)
      .eq('code', participantCode.toUpperCase())
      .eq('contest_id', contestId)
      .single();

    if (participantError || !participant) {
      return new Response(
        JSON.stringify({ success: false, error: 'INVALID_PARTICIPANT' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Verify category is published and belongs to contest
    const { data: category, error: categoryError } = await supabaseAdmin
      .from('categories')
      .select('id, type, status, deadline, division_id')
      .eq('id', categoryId)
      .single();

    if (categoryError || !category) {
      return new Response(
        JSON.stringify({ success: false, error: 'CATEGORY_NOT_FOUND' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Verify category is for videos
    if (category.type !== 'video') {
      return new Response(
        JSON.stringify({ success: false, error: 'CATEGORY_TYPE_MISMATCH' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Verify category status is published
    if (category.status !== 'published') {
      return new Response(
        JSON.stringify({ success: false, error: 'CATEGORY_CLOSED' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Verify deadline has not passed
    if (new Date(category.deadline) < new Date()) {
      return new Response(
        JSON.stringify({ success: false, error: 'DEADLINE_PASSED' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Check if participant already has a submission for this category
    const { data: existingSubmission } = await supabaseAdmin
      .from('submissions')
      .select('id, status')
      .eq('participant_id', participantId)
      .eq('category_id', categoryId)
      .single();

    let submissionId: string;

    if (existingSubmission) {
      // Allow re-upload if previous upload failed or is being replaced
      submissionId = existingSubmission.id;
      await supabaseAdmin
        .from('submissions')
        .update({ status: 'uploading', submitted_at: new Date().toISOString() })
        .eq('id', submissionId);
    } else {
      // Create new submission record
      const { data: newSubmission, error: insertError } = await supabaseAdmin
        .from('submissions')
        .insert({
          participant_id: participantId,
          category_id: categoryId,
          media_type: 'video',
          status: 'uploading',
          submitted_at: new Date().toISOString(),
        })
        .select('id')
        .single();

      if (insertError || !newSubmission) {
        throw new Error('SUBMISSION_CREATE_FAILED');
      }

      submissionId = newSubmission.id;
    }

    // Generate Bunny Stream TUS upload URL
    const BUNNY_STREAM_API_KEY = Deno.env.get('BUNNY_STREAM_API_KEY');
    const BUNNY_STREAM_LIBRARY_ID = Deno.env.get('BUNNY_STREAM_LIBRARY_ID');

    if (!BUNNY_STREAM_API_KEY || !BUNNY_STREAM_LIBRARY_ID) {
      throw new Error('BUNNY_CONFIG_MISSING');
    }

    // Create video in Bunny Stream
    const createVideoResponse = await fetch(
      `https://video.bunnycdn.com/library/${BUNNY_STREAM_LIBRARY_ID}/videos`,
      {
        method: 'POST',
        headers: {
          'AccessKey': BUNNY_STREAM_API_KEY,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: fileName,
          collectionId: contestId, // Organize by contest
        }),
      }
    );

    if (!createVideoResponse.ok) {
      throw new Error('BUNNY_VIDEO_CREATE_FAILED');
    }

    const videoData = await createVideoResponse.json();
    const bunnyVideoId = videoData.guid;

    // Update submission with bunny_video_id
    await supabaseAdmin
      .from('submissions')
      .update({ bunny_video_id: bunnyVideoId })
      .eq('id', submissionId);

    // Generate TUS upload URL
    // Bunny Stream TUS endpoint format
    const tusUploadUrl = `https://video.bunnycdn.com/tusupload`;
    const authorizationSignature = await generateTusSignature(
      BUNNY_STREAM_LIBRARY_ID,
      BUNNY_STREAM_API_KEY,
      bunnyVideoId,
      Math.floor(Date.now() / 1000) + 3600 // 1 hour expiry
    );

    return new Response(
      JSON.stringify({
        success: true,
        submissionId,
        bunnyVideoId,
        uploadUrl: tusUploadUrl,
        libraryId: BUNNY_STREAM_LIBRARY_ID,
        authorizationSignature,
        expirationTime: Math.floor(Date.now() / 1000) + 3600,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    const message = error instanceof Error ? error.message : 'UNKNOWN_ERROR';
    console.error('create-video-upload error:', message);
    return new Response(
      JSON.stringify({ success: false, error: message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});

// Generate TUS authorization signature for Bunny Stream
async function generateTusSignature(
  libraryId: string,
  apiKey: string,
  videoId: string,
  expirationTime: number
): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(`${libraryId}${apiKey}${expirationTime}${videoId}`);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}
```

### Edge Function: finalize-upload

**supabase/functions/finalize-upload/index.ts:**

```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface FinalizeRequest {
  submissionId: string;
  participantId: string;
  participantCode: string;
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  if (req.method !== 'POST') {
    return new Response(
      JSON.stringify({ success: false, error: 'METHOD_NOT_ALLOWED' }),
      { status: 405, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }

  try {
    const { submissionId, participantId, participantCode }: FinalizeRequest = await req.json();

    if (!submissionId || !participantId || !participantCode) {
      throw new Error('MISSING_REQUIRED_FIELDS');
    }

    const supabaseAdmin = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '',
      { auth: { autoRefreshToken: false, persistSession: false } }
    );

    // Verify submission belongs to participant
    const { data: submission, error: submissionError } = await supabaseAdmin
      .from('submissions')
      .select('id, participant_id, bunny_video_id, status')
      .eq('id', submissionId)
      .single();

    if (submissionError || !submission) {
      return new Response(
        JSON.stringify({ success: false, error: 'SUBMISSION_NOT_FOUND' }),
        { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (submission.participant_id !== participantId) {
      return new Response(
        JSON.stringify({ success: false, error: 'UNAUTHORIZED' }),
        { status: 403, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Verify participant code
    const { data: participant } = await supabaseAdmin
      .from('participants')
      .select('id')
      .eq('id', participantId)
      .eq('code', participantCode.toUpperCase())
      .single();

    if (!participant) {
      return new Response(
        JSON.stringify({ success: false, error: 'INVALID_PARTICIPANT' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Construct media URL from Bunny Stream
    const BUNNY_STREAM_LIBRARY_ID = Deno.env.get('BUNNY_STREAM_LIBRARY_ID');
    const mediaUrl = `https://iframe.mediadelivery.net/embed/${BUNNY_STREAM_LIBRARY_ID}/${submission.bunny_video_id}`;
    const thumbnailUrl = `https://vz-${BUNNY_STREAM_LIBRARY_ID}.b-cdn.net/${submission.bunny_video_id}/thumbnail.jpg`;

    // Update submission to submitted
    const { error: updateError } = await supabaseAdmin
      .from('submissions')
      .update({
        status: 'submitted',
        media_url: mediaUrl,
        thumbnail_url: thumbnailUrl,
      })
      .eq('id', submissionId);

    if (updateError) {
      throw new Error('SUBMISSION_UPDATE_FAILED');
    }

    return new Response(
      JSON.stringify({
        success: true,
        submissionId,
        mediaUrl,
        thumbnailUrl,
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    const message = error instanceof Error ? error.message : 'UNKNOWN_ERROR';
    console.error('finalize-upload error:', message);
    return new Response(
      JSON.stringify({ success: false, error: message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
```

### Type Definitions

**src/features/submissions/types/submission.types.ts:**

```typescript
export type SubmissionStatus = 'uploading' | 'submitted' | 'disqualified';
export type MediaType = 'video' | 'photo';

export interface Submission {
  id: string;
  participantId: string;
  categoryId: string;
  mediaType: MediaType;
  mediaUrl: string | null;
  bunnyVideoId: string | null;
  thumbnailUrl: string | null;
  status: SubmissionStatus;
  submittedAt: string;
  createdAt: string;
  updatedAt: string;
}

export interface UploadState {
  status: 'idle' | 'uploading' | 'processing' | 'complete' | 'error';
  progress: number;
  speed: number; // bytes per second
  fileName: string | null;
  error: string | null;
}

export const VIDEO_FORMATS = [
  '.mp4', '.mkv', '.m4v', '.mov', '.avi', '.flv', '.wmv', '.ts', '.mpeg'
] as const;

export const VIDEO_MIME_TYPES = [
  'video/mp4',
  'video/x-matroska',
  'video/x-m4v',
  'video/quicktime',
  'video/x-msvideo',
  'video/x-flv',
  'video/x-ms-wmv',
  'video/mp2t',
  'video/mpeg',
] as const;

export const MAX_VIDEO_SIZE = 500 * 1024 * 1024; // 500MB

export const VIDEO_ACCEPT = VIDEO_FORMATS.join(',');
```

### UploadProgress Component

**src/features/submissions/components/UploadProgress.tsx:**

```typescript
import { Progress } from '@/components/ui';
import { Upload, CheckCircle, XCircle, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import type { UploadState } from '../types/submission.types';

interface UploadProgressProps {
  state: UploadState;
  onRetry?: () => void;
  className?: string;
}

export function UploadProgress({ state, onRetry, className }: UploadProgressProps) {
  const formatSpeed = (bytesPerSecond: number): string => {
    if (bytesPerSecond < 1024) return `${bytesPerSecond.toFixed(0)} B/s`;
    if (bytesPerSecond < 1024 * 1024) return `${(bytesPerSecond / 1024).toFixed(1)} KB/s`;
    return `${(bytesPerSecond / (1024 * 1024)).toFixed(1)} MB/s`;
  };

  const formatProgress = (progress: number): string => {
    return `${Math.round(progress)}%`;
  };

  const getStatusIcon = () => {
    switch (state.status) {
      case 'idle':
        return <Upload className="h-8 w-8 text-muted-foreground" />;
      case 'uploading':
        return <Loader2 className="h-8 w-8 text-primary animate-spin" />;
      case 'processing':
        return <Loader2 className="h-8 w-8 text-primary animate-spin" />;
      case 'complete':
        return <CheckCircle className="h-8 w-8 text-green-600" />;
      case 'error':
        return <XCircle className="h-8 w-8 text-destructive" />;
    }
  };

  const getStatusText = () => {
    switch (state.status) {
      case 'idle':
        return 'Ready to upload';
      case 'uploading':
        return `Uploading... ${formatProgress(state.progress)}`;
      case 'processing':
        return 'Processing...';
      case 'complete':
        return 'Upload complete!';
      case 'error':
        return state.error || 'Upload failed';
    }
  };

  return (
    <div className={cn('rounded-lg border p-6 space-y-4', className)}>
      <div className="flex items-center gap-4">
        {getStatusIcon()}
        <div className="flex-1 min-w-0">
          {state.fileName && (
            <p className="font-medium truncate">{state.fileName}</p>
          )}
          <p className="text-sm text-muted-foreground">{getStatusText()}</p>
        </div>
      </div>

      {(state.status === 'uploading' || state.status === 'processing') && (
        <div className="space-y-2">
          <Progress value={state.progress} className="h-2" />
          <div className="flex justify-between text-xs text-muted-foreground">
            <span>{formatProgress(state.progress)}</span>
            {state.status === 'uploading' && state.speed > 0 && (
              <span>{formatSpeed(state.speed)}</span>
            )}
          </div>
        </div>
      )}

      {state.status === 'error' && onRetry && (
        <button
          onClick={onRetry}
          className="text-sm text-primary hover:underline"
        >
          Retry upload
        </button>
      )}
    </div>
  );
}
```

### VideoUploadForm Component

**src/features/submissions/components/VideoUploadForm.tsx:**

```typescript
import { useState, useRef, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { Upload } from 'lucide-react';
import { toast } from 'sonner';
import { Button, Card, CardContent } from '@/components/ui';
import { UploadProgress } from './UploadProgress';
import { useVideoUpload } from '../hooks/useVideoUpload';
import {
  VIDEO_ACCEPT,
  VIDEO_MIME_TYPES,
  MAX_VIDEO_SIZE,
} from '../types/submission.types';
import { cn } from '@/lib/utils';

interface VideoUploadFormProps {
  contestId: string;
  categoryId: string;
  participantId: string;
  participantCode: string;
  onUploadComplete: (submissionId: string) => void;
}

export function VideoUploadForm({
  contestId,
  categoryId,
  participantId,
  participantCode,
  onUploadComplete,
}: VideoUploadFormProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const { uploadState, startUpload, retryUpload, cancelUpload } = useVideoUpload({
    contestId,
    categoryId,
    participantId,
    participantCode,
    onComplete: onUploadComplete,
  });

  const validateFile = (file: File): string | null => {
    // Check file type
    const isValidType = VIDEO_MIME_TYPES.some(
      (type) => file.type === type || file.name.toLowerCase().endsWith(type.split('/')[1])
    );
    if (!isValidType) {
      return 'Invalid file type. Supported formats: MP4, MKV, MOV, AVI, WMV, FLV, TS, MPEG';
    }

    // Check file size
    if (file.size > MAX_VIDEO_SIZE) {
      return 'File too large. Maximum size is 500MB';
    }

    return null;
  };

  const handleFileSelect = useCallback((file: File) => {
    const error = validateFile(file);
    if (error) {
      toast.error(error);
      return;
    }
    startUpload(file);
  }, [startUpload]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
    // Reset input so same file can be selected again
    e.target.value = '';
  };

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    const file = e.dataTransfer.files[0];
    if (file) {
      handleFileSelect(file);
    }
  }, [handleFileSelect]);

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  // Navigation warning during upload
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (uploadState.status === 'uploading' || uploadState.status === 'processing') {
        e.preventDefault();
        e.returnValue = 'Upload in progress. Are you sure you want to leave?';
        return e.returnValue;
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [uploadState.status]);

  const isUploading = uploadState.status === 'uploading' || uploadState.status === 'processing';

  return (
    <div className="space-y-6">
      {/* File picker / drop zone */}
      {uploadState.status === 'idle' && (
        <Card
          className={cn(
            'border-2 border-dashed transition-colors cursor-pointer',
            isDragging && 'border-primary bg-primary/5'
          )}
          onDrop={handleDrop}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onClick={() => fileInputRef.current?.click()}
        >
          <CardContent className="py-12 text-center">
            <Upload className="h-12 w-12 mx-auto text-muted-foreground mb-4" />
            <p className="text-lg font-medium mb-2">
              Drop your video here or click to browse
            </p>
            <p className="text-sm text-muted-foreground mb-4">
              Supported formats: MP4, MKV, MOV, AVI, WMV, FLV, TS, MPEG
            </p>
            <p className="text-sm text-muted-foreground">
              Maximum file size: 500MB
            </p>
            <input
              ref={fileInputRef}
              type="file"
              accept={VIDEO_ACCEPT}
              onChange={handleInputChange}
              className="hidden"
            />
          </CardContent>
        </Card>
      )}

      {/* Upload progress */}
      {uploadState.status !== 'idle' && (
        <UploadProgress
          state={uploadState}
          onRetry={uploadState.status === 'error' ? retryUpload : undefined}
        />
      )}

      {/* Cancel button during upload */}
      {isUploading && (
        <div className="text-center">
          <Button variant="outline" onClick={cancelUpload}>
            Cancel Upload
          </Button>
        </div>
      )}
    </div>
  );
}

// Import useEffect at the top
import { useEffect } from 'react';
```

### useVideoUpload Hook

**src/features/submissions/hooks/useVideoUpload.ts:**

```typescript
import { useState, useCallback, useRef } from 'react';
import * as tus from 'tus-js-client';
import { supabase } from '@/lib/supabase';
import type { UploadState } from '../types/submission.types';

interface UseVideoUploadParams {
  contestId: string;
  categoryId: string;
  participantId: string;
  participantCode: string;
  onComplete: (submissionId: string) => void;
}

export function useVideoUpload({
  contestId,
  categoryId,
  participantId,
  participantCode,
  onComplete,
}: UseVideoUploadParams) {
  const [uploadState, setUploadState] = useState<UploadState>({
    status: 'idle',
    progress: 0,
    speed: 0,
    fileName: null,
    error: null,
  });

  const uploadRef = useRef<tus.Upload | null>(null);
  const fileRef = useRef<File | null>(null);
  const submissionIdRef = useRef<string | null>(null);
  const lastProgressTimeRef = useRef<number>(0);
  const lastUploadedRef = useRef<number>(0);

  const startUpload = useCallback(async (file: File) => {
    fileRef.current = file;

    setUploadState({
      status: 'uploading',
      progress: 0,
      speed: 0,
      fileName: file.name,
      error: null,
    });

    try {
      // Get signed upload URL from Edge Function
      const { data, error } = await supabase.functions.invoke('create-video-upload', {
        body: {
          contestId,
          categoryId,
          participantId,
          participantCode,
          fileName: file.name,
          fileSize: file.size,
        },
      });

      if (error || !data?.success) {
        const errorCode = data?.error || error?.message || 'UPLOAD_INIT_FAILED';
        const errorMessage = getErrorMessage(errorCode);
        setUploadState(prev => ({
          ...prev,
          status: 'error',
          error: errorMessage,
        }));
        return;
      }

      const { submissionId, bunnyVideoId, libraryId, authorizationSignature, expirationTime } = data;
      submissionIdRef.current = submissionId;

      // Create TUS upload
      const upload = new tus.Upload(file, {
        endpoint: 'https://video.bunnycdn.com/tusupload',
        retryDelays: [0, 1000, 3000, 5000],
        metadata: {
          filetype: file.type,
          title: file.name,
        },
        headers: {
          AuthorizationSignature: authorizationSignature,
          AuthorizationExpire: expirationTime.toString(),
          VideoId: bunnyVideoId,
          LibraryId: libraryId,
        },
        onError: (error) => {
          console.error('TUS upload error:', error);
          setUploadState(prev => ({
            ...prev,
            status: 'error',
            error: 'Upload failed. Please try again.',
          }));
        },
        onProgress: (bytesUploaded, bytesTotal) => {
          const progress = (bytesUploaded / bytesTotal) * 100;

          // Calculate speed
          const now = Date.now();
          const timeDiff = (now - lastProgressTimeRef.current) / 1000; // seconds
          const bytesDiff = bytesUploaded - lastUploadedRef.current;
          const speed = timeDiff > 0 ? bytesDiff / timeDiff : 0;

          lastProgressTimeRef.current = now;
          lastUploadedRef.current = bytesUploaded;

          setUploadState(prev => ({
            ...prev,
            progress,
            speed,
          }));
        },
        onSuccess: async () => {
          setUploadState(prev => ({
            ...prev,
            status: 'processing',
            progress: 100,
          }));

          // Finalize upload
          const { data: finalizeData, error: finalizeError } = await supabase.functions.invoke(
            'finalize-upload',
            {
              body: {
                submissionId: submissionIdRef.current,
                participantId,
                participantCode,
              },
            }
          );

          if (finalizeError || !finalizeData?.success) {
            setUploadState(prev => ({
              ...prev,
              status: 'error',
              error: 'Failed to finalize upload. Please try again.',
            }));
            return;
          }

          setUploadState(prev => ({
            ...prev,
            status: 'complete',
          }));

          onComplete(submissionIdRef.current!);
        },
      });

      uploadRef.current = upload;

      // Check for previous upload to resume
      const previousUploads = await upload.findPreviousUploads();
      if (previousUploads.length > 0) {
        upload.resumeFromPreviousUpload(previousUploads[0]);
      }

      upload.start();
    } catch (error) {
      console.error('Upload start error:', error);
      setUploadState(prev => ({
        ...prev,
        status: 'error',
        error: 'Failed to start upload. Please try again.',
      }));
    }
  }, [contestId, categoryId, participantId, participantCode, onComplete]);

  const retryUpload = useCallback(() => {
    if (fileRef.current) {
      startUpload(fileRef.current);
    }
  }, [startUpload]);

  const cancelUpload = useCallback(() => {
    if (uploadRef.current) {
      uploadRef.current.abort();
    }
    setUploadState({
      status: 'idle',
      progress: 0,
      speed: 0,
      fileName: null,
      error: null,
    });
  }, []);

  return {
    uploadState,
    startUpload,
    retryUpload,
    cancelUpload,
  };
}

function getErrorMessage(errorCode: string): string {
  const messages: Record<string, string> = {
    FILE_TOO_LARGE: 'File too large. Maximum size is 500MB',
    INVALID_PARTICIPANT: 'Invalid participant session. Please re-enter your codes.',
    CATEGORY_NOT_FOUND: 'Category not found.',
    CATEGORY_TYPE_MISMATCH: 'This category does not accept video submissions.',
    CATEGORY_CLOSED: 'This category is no longer accepting submissions.',
    DEADLINE_PASSED: 'The deadline for this category has passed.',
    BUNNY_CONFIG_MISSING: 'Upload service configuration error. Please contact support.',
    UPLOAD_INIT_FAILED: 'Failed to initialize upload. Please try again.',
  };
  return messages[errorCode] || 'An unexpected error occurred. Please try again.';
}
```

### VideoUploadPage

**src/pages/participant/VideoUploadPage.tsx:**

```typescript
import { useNavigate, useParams } from 'react-router-dom';
import { ArrowLeft } from 'lucide-react';
import { Button, Card, CardContent, CardHeader, CardTitle } from '@/components/ui';
import { VideoUploadForm } from '@/features/submissions';
import { useParticipantSession } from '@/contexts';

export function VideoUploadPage() {
  const navigate = useNavigate();
  const { categoryId } = useParams<{ categoryId: string }>();
  const { session } = useParticipantSession();

  if (!session || !categoryId) {
    navigate('/enter', { replace: true });
    return null;
  }

  const handleUploadComplete = (submissionId: string) => {
    navigate(`/participant/preview/${submissionId}`);
  };

  const handleBack = () => {
    navigate('/participant/categories');
  };

  return (
    <div className="min-h-screen bg-background p-4 sm:p-6">
      <div className="max-w-2xl mx-auto space-y-6">
        {/* Header */}
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="icon" onClick={handleBack}>
            <ArrowLeft className="h-5 w-5" />
          </Button>
          <div>
            <h1 className="text-2xl font-bold">Upload Video</h1>
            <p className="text-muted-foreground">
              Submit your video entry
            </p>
          </div>
        </div>

        {/* Upload Form */}
        <Card>
          <CardHeader>
            <CardTitle>Select Your Video</CardTitle>
          </CardHeader>
          <CardContent>
            <VideoUploadForm
              contestId={session.contestId}
              categoryId={categoryId}
              participantId={session.participantId}
              participantCode={session.code}
              onUploadComplete={handleUploadComplete}
            />
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

### Router Update

Add to `src/router/router.tsx`:

```typescript
// In participant routes
{
  path: 'submit/:categoryId',
  element: (
    <RequireParticipantSession>
      <VideoUploadPage />
    </RequireParticipantSession>
  ),
},
{
  path: 'preview/:submissionId',
  element: (
    <RequireParticipantSession>
      <SubmissionPreviewPage /> // Story 4.6
    </RequireParticipantSession>
  ),
},
```

### Dependencies

**Install TUS client:**
```bash
npm install tus-js-client
npm install -D @types/tus-js-client
```

### Previous Story Intelligence

**From Story 4-3 (Categories):**
- ParticipantCategoryCard navigates to `/participant/submit/${category.id}`
- Category type is available from context for conditional routing
- Session provides: contestId, participantId, code, name

**From Story 4-1/4-2 (Session):**
- ParticipantSessionContext validated and stable
- Session expiry warning handled at layout level
- Edge Functions use service_role for participant operations

**Review Follow-ups from 4-3:**
- Deep import issues identified → Ensure all imports from feature index
- Button hierarchy concerns → Use single primary action per view

### Testing Guidance

**Unit Tests (UploadProgress.test.tsx):**

1. **Idle state:** Shows ready message, upload icon
2. **Uploading state:** Shows progress bar, percentage, speed
3. **Processing state:** Shows processing message, spinner
4. **Complete state:** Shows success message, checkmark
5. **Error state:** Shows error message, retry button

**Unit Tests (VideoUploadForm.test.tsx):**

1. **File validation - valid file:** Starts upload
2. **File validation - too large:** Shows error toast, no upload
3. **File validation - invalid type:** Shows error toast, no upload
4. **Drag and drop:** File accepted on drop
5. **Navigation warning:** beforeunload triggered during upload

**Integration Tests (VideoUploadPage.test.tsx):**

1. **No session:** Redirects to /enter
2. **Back button:** Navigates to categories
3. **Upload complete:** Navigates to preview page

### Quality Gates

Before marking as "review":

```bash
# Git Status (REQUIRED)
git status          # Must show clean
git log --oneline -5  # Verify commits have "4-4:" prefix
git push -u origin story/4-4-video-upload-with-progress

# Quality Gates (REQUIRED)
npm run build       # Must pass
npm run lint        # Must pass
npm run type-check  # Must pass
npm run test        # Must pass

# Database Migration (REQUIRED)
npx supabase migration new create_submissions
# Then add SQL and run:
npx supabase db push

# Edge Function Deployment (REQUIRED)
npx supabase functions deploy create-video-upload
npx supabase functions deploy finalize-upload

# Environment Variables (REQUIRED)
# Verify in Supabase dashboard:
# - BUNNY_STREAM_API_KEY
# - BUNNY_STREAM_LIBRARY_ID

# Manual Test Checklist (REQUIRED)
# 1. Navigate to video category → Click Submit
# 2. Select valid video < 500MB → Upload starts
# 3. Progress bar updates smoothly with speed
# 4. Try to navigate away → Warning shown
# 5. Upload completes → Redirects to preview
# 6. Select file > 500MB → Error "File too large"
# 7. Select .pdf file → Error "Invalid file type"
# 8. Disconnect network mid-upload → Error with Retry
# 9. Click Retry → Upload resumes
```

### Reference Documents

- [Source: epic-4-participant-submission-experience.md#Story 4.4]
- [Source: project-context.md#Bunny Upload Security]
- [Source: core-architectural-decisions.md#Bunny Upload Security]
- [Source: component-strategy.md#UploadProgress]
- [Source: 4-3-view-categories-submission-status.md] (navigation patterns)
- [Source: implementation-patterns-consistency-rules.md] (naming, error handling)

## Tasks / Subtasks

- [ ] Create submissions table migration (AC9)
  - [ ] Create migration file
  - [ ] Add RLS policies
  - [ ] Run `npx supabase db push`

- [ ] Install TUS client dependency
  - [ ] `npm install tus-js-client`
  - [ ] `npm install -D @types/tus-js-client`

- [ ] Create Edge Functions (AC8)
  - [ ] Create supabase/functions/create-video-upload/index.ts
  - [ ] Create supabase/functions/finalize-upload/index.ts
  - [ ] Deploy both functions

- [ ] Create submission types (AC1, AC5, AC6)
  - [ ] Create src/features/submissions/types/submission.types.ts
  - [ ] Define video formats and size constants

- [ ] Create UploadProgress component (AC2, AC3)
  - [ ] Create src/features/submissions/components/UploadProgress.tsx
  - [ ] Handle all states: idle, uploading, processing, complete, error
  - [ ] Show progress bar, percentage, speed
  - [ ] Create UploadProgress.test.tsx

- [ ] Create useVideoUpload hook (AC2, AC3, AC7)
  - [ ] Create src/features/submissions/hooks/useVideoUpload.ts
  - [ ] Integrate TUS client for resumable uploads
  - [ ] Track progress and speed
  - [ ] Handle retry logic

- [ ] Create VideoUploadForm component (AC1-AC7)
  - [ ] Create src/features/submissions/components/VideoUploadForm.tsx
  - [ ] File picker with drag-and-drop
  - [ ] Validation for size and type
  - [ ] Navigation warning during upload
  - [ ] Create VideoUploadForm.test.tsx

- [ ] Create VideoUploadPage (AC1-AC4)
  - [ ] Create src/pages/participant/VideoUploadPage.tsx
  - [ ] Integrate with session context
  - [ ] Handle navigation to preview
  - [ ] Create VideoUploadPage.test.tsx

- [ ] Update router
  - [ ] Add /participant/submit/:categoryId route
  - [ ] Add /participant/preview/:submissionId route (placeholder)

- [ ] Update feature exports
  - [ ] Export all components from index.ts
  - [ ] Export hooks and types

- [ ] Run quality gates and verify

### Review Follow-ups (AI)
- [ ] [AI-Review][High] Add SPA navigation blocking during upload (route change warning). `src/features/submissions/components/VideoUploadForm.tsx:107`
- [ ] [AI-Review][High] Validate category belongs to contest during create-video-upload (use contestId in category query). `supabase/functions/create-video-upload/index.ts:102`
- [ ] [AI-Review][High] Enforce one submission per participant/category or explicitly gate re-uploads. `supabase/functions/create-video-upload/index.ts:153`
- [ ] [AI-Review][Medium] Include .m4v in UI copy and invalid type error string. `src/features/submissions/components/VideoUploadForm.tsx:57`
- [ ] [AI-Review][Medium] Use signed uploadUrl returned by edge function instead of hardcoded endpoint. `src/features/submissions/hooks/useVideoUpload.ts:93`
- [ ] [AI-Review][Medium] Update story metadata (status/tasks/file list) to match implementation. `_bmad-output/implementation-artifacts/4-4-video-upload-with-progress.md:3`

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes

### File List
